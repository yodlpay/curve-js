import memoize from "memoizee";
import { IDict, IReward, IProfit } from '../interfaces';
import { IGaugePool } from "./gaugePool.js";
export declare class PoolTemplate {
    id: string;
    name: string;
    fullName: string;
    symbol: string;
    referenceAsset: string;
    address: string;
    lpToken: string;
    gauge: IGaugePool;
    zap: string | null;
    sRewardContract: string | null;
    rewardContract: string | null;
    implementation: string | null;
    isPlain: boolean;
    isLending: boolean;
    isMeta: boolean;
    isCrypto: boolean;
    isFake: boolean;
    isFactory: boolean;
    isMetaFactory: boolean;
    isNg: boolean;
    isLlamma: boolean;
    basePool: string;
    metaCoinIdx: number;
    underlyingCoins: string[];
    wrappedCoins: string[];
    underlyingCoinAddresses: string[];
    wrappedCoinAddresses: string[];
    underlyingDecimals: number[];
    wrappedDecimals: number[];
    useLending: boolean[];
    inApi: boolean;
    isGaugeKilled: () => Promise<boolean>;
    gaugeStatus: () => Promise<any>;
    estimateGas: {
        depositApprove: (amounts: (number | string)[]) => Promise<number | number[]>;
        deposit: (amounts: (number | string)[]) => Promise<number | number[]>;
        depositWrappedApprove: (amounts: (number | string)[]) => Promise<number | number[]>;
        depositWrapped: (amounts: (number | string)[]) => Promise<number | number[]>;
        stakeApprove: (lpTokenAmount: number | string) => Promise<number | number[]>;
        stake: (lpTokenAmount: number | string) => Promise<number | number[]>;
        unstake: (lpTokenAmount: number | string) => Promise<number | number[]>;
        claimCrv: () => Promise<number | number[]>;
        claimRewards: () => Promise<number | number[]>;
        depositAndStakeApprove: (amounts: (number | string)[]) => Promise<number | number[]>;
        depositAndStake: (amounts: (number | string)[]) => Promise<number>;
        depositAndStakeWrappedApprove: (amounts: (number | string)[]) => Promise<number | number[]>;
        depositAndStakeWrapped: (amounts: (number | string)[]) => Promise<number | number[]>;
        withdrawApprove: (lpTokenAmount: number | string) => Promise<number | number[]>;
        withdraw: (lpTokenAmount: number | string) => Promise<number | number[]>;
        withdrawWrapped: (lpTokenAmount: number | string) => Promise<number | number[]>;
        withdrawImbalanceApprove: (amounts: (number | string)[]) => Promise<number | number[]>;
        withdrawImbalance: (amounts: (number | string)[]) => Promise<number | number[]>;
        withdrawImbalanceWrapped: (amounts: (number | string)[]) => Promise<number | number[]>;
        withdrawOneCoinApprove: (lpTokenAmount: number | string) => Promise<number | number[]>;
        withdrawOneCoin: (lpTokenAmount: number | string, coin: string | number) => Promise<number | number[]>;
        withdrawOneCoinWrapped: (lpTokenAmount: number | string, coin: string | number) => Promise<number | number[]>;
        swapApprove: (inputCoin: string | number, amount: number | string) => Promise<number | number[]>;
        swap: (inputCoin: string | number, outputCoin: string | number, amount: number | string, slippage: number) => Promise<number | number[]>;
        swapWrappedApprove: (inputCoin: string | number, amount: number | string) => Promise<number | number[]>;
        swapWrapped: (inputCoin: string | number, outputCoin: string | number, amount: number | string, slippage: number) => Promise<number | number[]>;
    };
    stats: {
        parameters: () => Promise<{
            lpTokenSupply: string;
            virtualPrice: string;
            fee: string;
            adminFee: string;
            A: string;
            future_A?: string;
            initial_A?: string;
            future_A_time?: number;
            initial_A_time?: number;
            gamma?: string;
            price_oracle?: string[];
            price_scale?: string[];
        }>;
        underlyingBalances: () => Promise<string[]>;
        wrappedBalances: () => Promise<string[]>;
        totalLiquidity: (useApi?: boolean) => Promise<string>;
        volume: () => Promise<string>;
        baseApy: () => Promise<{
            day: string;
            week: string;
        }>;
        tokenApy: (useApi?: boolean) => Promise<[baseApy: number, boostedApy: number]>;
        rewardsApy: (useApi?: boolean) => Promise<IReward[]>;
    };
    wallet: {
        balances: (...addresses: string[] | string[][]) => Promise<IDict<IDict<string>> | IDict<string>>;
        lpTokenBalances: (...addresses: string[] | string[][]) => Promise<IDict<IDict<string>> | IDict<string>>;
        underlyingCoinBalances: (...addresses: string[] | string[][]) => Promise<IDict<IDict<string>> | IDict<string>>;
        wrappedCoinBalances: (...addresses: string[] | string[][]) => Promise<IDict<IDict<string>> | IDict<string>>;
        allCoinBalances: (...addresses: string[] | string[][]) => Promise<IDict<IDict<string>> | IDict<string>>;
    };
    constructor(id: string);
    hasVyperVulnerability(): boolean;
    rewardsOnly(): boolean;
    private statsParameters;
    private statsWrappedBalances;
    private statsUnderlyingBalances;
    private statsTotalLiquidity;
    private statsVolume;
    private statsBaseApy;
    private _calcTokenApy;
    private statsTokenApy;
    private statsRewardsApy;
    private _pureCalcLpTokenAmount;
    private _calcLpTokenAmount;
    private calcLpTokenAmount;
    private calcLpTokenAmountWrapped;
    metaUnderlyingSeedAmounts(amount1: number | string): string[];
    cryptoSeedAmounts(amount1: number | string): Promise<string[]>;
    depositBalancedAmounts(): Promise<string[]>;
    depositExpected(amounts: (number | string)[]): Promise<string>;
    private _balancedAmountsWithSameValue;
    depositBonus(amounts: (number | string)[]): Promise<string>;
    depositIsApproved(amounts: (number | string)[]): Promise<boolean>;
    private depositApproveEstimateGas;
    depositApprove(amounts: (number | string)[], isMax?: boolean): Promise<string[]>;
    private depositEstimateGas;
    deposit(amounts: (number | string)[], slippage?: number): Promise<string>;
    depositWrappedBalancedAmounts(): Promise<string[]>;
    depositWrappedExpected(amounts: (number | string)[]): Promise<string>;
    depositWrappedBonus(amounts: (number | string)[]): Promise<string>;
    depositWrappedIsApproved(amounts: (number | string)[]): Promise<boolean>;
    private depositWrappedApproveEstimateGas;
    depositWrappedApprove(amounts: (number | string)[]): Promise<string[]>;
    private depositWrappedEstimateGas;
    depositWrapped(amounts: (number | string)[], slippage?: number): Promise<string>;
    stakeIsApproved(lpTokenAmount: number | string): Promise<boolean>;
    private stakeApproveEstimateGas;
    stakeApprove(lpTokenAmount: number | string): Promise<string[]>;
    private stakeEstimateGas;
    stake(lpTokenAmount: number | string): Promise<string>;
    private unstakeEstimateGas;
    unstake(lpTokenAmount: number | string): Promise<string>;
    crvProfit: (address?: string) => Promise<IProfit>;
    claimableCrv(address?: string): Promise<string>;
    claimCrvEstimateGas(): Promise<number | number[]>;
    claimCrv(): Promise<string>;
    userBoost: (address?: string) => Promise<string>;
    private _userFutureBoostAndWorkingSupply;
    userFutureBoost: (address?: string) => Promise<string>;
    userCrvApy: (address?: string) => Promise<number>;
    userFutureCrvApy: (address?: string) => Promise<number>;
    maxBoostedStake: (...addresses: string[]) => Promise<IDict<string> | string>;
    rewardTokens: ((useApi?: any) => Promise<{
        token: string;
        symbol: string;
        decimals: number;
    }[]>) & memoize.Memoized<(useApi?: any) => Promise<{
        token: string;
        symbol: string;
        decimals: number;
    }[]>>;
    rewardsProfit: (address?: string) => Promise<IProfit[]>;
    claimableRewards(address?: string): Promise<{
        token: string;
        symbol: string;
        amount: string;
    }[]>;
    claimRewardsEstimateGas(): Promise<number | number[]>;
    claimRewards(): Promise<string>;
    depositAndStakeExpected(amounts: (number | string)[]): Promise<string>;
    depositAndStakeBonus(amounts: (number | string)[]): Promise<string>;
    depositAndStakeIsApproved(amounts: (number | string)[]): Promise<boolean>;
    private depositAndStakeApproveEstimateGas;
    depositAndStakeApprove(amounts: (number | string)[]): Promise<string[]>;
    private depositAndStakeEstimateGas;
    depositAndStake(amounts: (number | string)[], slippage?: number): Promise<string>;
    depositAndStakeWrappedExpected(amounts: (number | string)[]): Promise<string>;
    depositAndStakeWrappedBonus(amounts: (number | string)[]): Promise<string>;
    depositAndStakeWrappedIsApproved(amounts: (number | string)[]): Promise<boolean>;
    private depositAndStakeWrappedApproveEstimateGas;
    depositAndStakeWrappedApprove(amounts: (number | string)[]): Promise<string[]>;
    private depositAndStakeWrappedEstimateGas;
    depositAndStakeWrapped(amounts: (number | string)[], slippage?: number): Promise<string>;
    private _depositAndStake;
    withdrawExpected(lpTokenAmount: number | string): Promise<string[]>;
    withdrawIsApproved(lpTokenAmount: number | string): Promise<boolean>;
    private withdrawApproveEstimateGas;
    withdrawApprove(lpTokenAmount: number | string): Promise<string[]>;
    private withdrawEstimateGas;
    withdraw(lpTokenAmount: number | string, slippage?: number): Promise<string>;
    withdrawWrappedExpected(lpTokenAmount: number | string): Promise<string[]>;
    private withdrawWrappedEstimateGas;
    withdrawWrapped(lpTokenAmount: number | string, slippage?: number): Promise<string>;
    withdrawImbalanceExpected(amounts: (number | string)[]): Promise<string>;
    withdrawImbalanceBonus(amounts: (number | string)[]): Promise<string>;
    withdrawImbalanceIsApproved(amounts: (number | string)[]): Promise<boolean>;
    private withdrawImbalanceApproveEstimateGas;
    withdrawImbalanceApprove(amounts: (number | string)[]): Promise<string[]>;
    private withdrawImbalanceEstimateGas;
    withdrawImbalance(amounts: (number | string)[], slippage?: number): Promise<string>;
    withdrawImbalanceWrappedExpected(amounts: (number | string)[]): Promise<string>;
    withdrawImbalanceWrappedBonus(amounts: (number | string)[]): Promise<string>;
    private withdrawImbalanceWrappedEstimateGas;
    withdrawImbalanceWrapped(amounts: (number | string)[], slippage?: number): Promise<string>;
    private _withdrawOneCoinExpected;
    withdrawOneCoinExpected(lpTokenAmount: number | string, coin: string | number): Promise<string>;
    withdrawOneCoinBonus(lpTokenAmount: number | string, coin: string | number): Promise<string>;
    withdrawOneCoinIsApproved(lpTokenAmount: number | string): Promise<boolean>;
    private withdrawOneCoinApproveEstimateGas;
    withdrawOneCoinApprove(lpTokenAmount: number | string): Promise<string[]>;
    private withdrawOneCoinEstimateGas;
    withdrawOneCoin(lpTokenAmount: number | string, coin: string | number, slippage?: number): Promise<string>;
    private _withdrawOneCoinWrappedExpected;
    withdrawOneCoinWrappedExpected(lpTokenAmount: number | string, coin: string | number): Promise<string>;
    withdrawOneCoinWrappedBonus(lpTokenAmount: number | string, coin: string | number): Promise<string>;
    private withdrawOneCoinWrappedEstimateGas;
    withdrawOneCoinWrapped(lpTokenAmount: number | string, coin: string | number, slippage?: number): Promise<string>;
    private walletBalances;
    private walletLpTokenBalances;
    private walletUnderlyingCoinBalances;
    private walletWrappedCoinBalances;
    private walletAllCoinBalances;
    private _userLpTotalBalance;
    userBalances(address?: string): Promise<string[]>;
    userWrappedBalances(address?: string): Promise<string[]>;
    userLiquidityUSD(address?: string): Promise<string>;
    baseProfit(address?: string): Promise<{
        day: string;
        week: string;
        month: string;
        year: string;
    }>;
    userShare(address?: string): Promise<{
        lpUser: string;
        lpTotal: string;
        lpShare: string;
        gaugeUser?: string;
        gaugeTotal?: string;
        gaugeShare?: string;
    }>;
    private _swapExpected;
    swapExpected(inputCoin: string | number, outputCoin: string | number, amount: number | string): Promise<string>;
    private _swapRequired;
    swapRequired(inputCoin: string | number, outputCoin: string | number, amount: number | string): Promise<string>;
    swapWrappedRequired(inputCoin: string | number, outputCoin: string | number, amount: number | string): Promise<string>;
    swapPriceImpact(inputCoin: string | number, outputCoin: string | number, amount: number | string): Promise<number>;
    private _swapContractAddress;
    swapIsApproved(inputCoin: string | number, amount: number | string): Promise<boolean>;
    private swapApproveEstimateGas;
    swapApprove(inputCoin: string | number, amount: number | string): Promise<string[]>;
    private swapEstimateGas;
    swap(inputCoin: string | number, outputCoin: string | number, amount: number | string, slippage?: number): Promise<string>;
    private _swapWrappedExpected;
    swapWrappedExpected(inputCoin: string | number, outputCoin: string | number, amount: number | string): Promise<string>;
    swapWrappedPriceImpact(inputCoin: string | number, outputCoin: string | number, amount: number | string): Promise<number>;
    swapWrappedIsApproved(inputCoin: string | number, amount: number | string): Promise<boolean>;
    private swapWrappedApproveEstimateGas;
    swapWrappedApprove(inputCoin: string | number, amount: number | string): Promise<string[]>;
    private swapWrappedEstimateGas;
    swapWrapped(inputCoin: string | number, outputCoin: string | number, amount: number | string, slippage?: number): Promise<string>;
    gaugeOptimalDeposits: (...accounts: string[]) => Promise<IDict<string>>;
    private _getCoinIdx;
    private _getRates;
    private _balances;
    private _stored_rates;
    private _underlyingPrices;
    private _wrappedPrices;
    private getGaugeStatus;
    private getIsGaugeKilled;
}
